include ../../templates/common.jade

doctype html
html
  head
    include ../../templates/head
    include ../../templates/explanation-head
    link(rel="stylesheet" href= path + "style.css" type="text/css")
  body(ng-app="myApp" ng-controller="MainCtrl")
    div(ng-controller="MigrationCtrl")
      section.menu
        a(href=basepath) Back
      section.title
        .title-region
          h1.title !{title}
          h3.by-line !{subtitle}
        +share
      section
        +authors
        p
          :markdown
            Eigen vectors and values may sound esoteric but their usefulness is almost unending. They made Sergie Brin and Larry Page of Google billions when they used them to calculate [result rankings](http://www.rose-hulman.edu/~bryan/googleFinalVersionFixed.pdf) for their search engine. They're also used extensively in other fields like engineering to prevent strutural resonance of the likes that can cause [bridges to collapse](https://www.youtube.com/watch?v=j-zczJXSxnw). Not to mention all the machine learning and artificial intelligence algorithms that depend on them to do things like detect your [friends faces](https://en.wikipedia.org/wiki/Eigenface) on sites like Facebook.
        p So what are they? And why are they so useful? To answer these questions, let's start things off with a simple example.
        p Let's try to come up with a model for guessing (estimating) the future population of every state of America. Wait. Actually... Our real goal is to learn what an eigen vector is useful for so let's stick to using only two states for now; 
          span.primary California
          |  and 
          span.secondary New York
          | . This ignores people migrating from other states. Our model assumes they don't exist or don't matter.  It also ignores the fact that people are born or die.
        sf-to-ny-migration-map
        //- h1 Predicting population growth
        p In the map above, the arrows represent the ratio of people each month that either stay or leave their state. If you adjust the ratios below, you'll see how they effect the map above. Notice how the ratio of people that decide each month to leave 
          span.primary California
          |  for 
          span.secondary New York
          |  , 
          b {{opts.basis1[0] | number:2 }}
          |  , plus the number of people that decide to stay, 
          b {{opts.basis1[1] | number:2 }}
          |  , always totals to 
          b 1
          |  (or 100%). If we were dealing with all 50 states, every vector would contain 50 numbers instead of 2 and still add up to 1, but then we wouldn't be able to draw them in 2D.
        sf-to-ny-data-as-vectors
        p Let's use vector notation to make referring to all the vectors above a bit easier. This is also how we would keep track of these vectors if they were length 50 instead of 2.
        migration-vector-notation
        p One (boring) way to calculate the population ratio one month from now (
          span.tertiary P₁
          | ) is to use arithmetic. For the population of CA a month from now (t=1), we get this equation:
        p(style="text-align: center")
          span(ev-tooltip="The proportion of people in CA at t=1")
            span.tertiary P₁[
            span.primary CA
            span.tertiary ]
          |  = 
          span(ev-tooltip="The proportion of people in CA at t=0")
            span.tertiary P₀[
            span.primary CA
            span.tertiary ]
          |  × 
          span(ev-tooltip="The proportion of people in CA that will stay in CA.")
            span.primary B₁[CA] 
          |  + 
          span(ev-tooltip="The proportion of people in NY at t=0")
            span.tertiary P₀[
            span.secondary NY
            span.tertiary ]
          |  × 
          span(ev-tooltip="The proportion of people in NY that will leave for CA.")
            span.secondary B₂[
            span.primary CA
            span.secondary ]
        p(style="text-align: center; color: rgba(0, 0, 0, 0.4)") in our case...
        p(style="text-align: center")
          b {{opts.samples[1][0] | number:2 }}
          | &nbsp;&nbsp;=&nbsp;&nbsp; {{opts.samples[0][0] | number:2 }} 
          | &nbsp;&nbsp;×&nbsp;&nbsp; {{opts.basis1[0] | number:2 }}
          | &nbsp;&nbsp;+&nbsp;&nbsp; {{opts.samples[0][1] | number:2 }} 
          | &nbsp;&nbsp;×&nbsp;&nbsp; {{opts.basis2[1] | number:2 }}

        p And for the population of NY at t=1 we get...
        p(style="text-align: center")
          span(ev-tooltip="The proportion of people in NY at t=1")
            span.tertiary P₁[
            span.secondary NY
            span.tertiary ]
          |  = 
          span(ev-tooltip="The proportion of people in CA at t=0")
            span.tertiary P₀[
            span.primary CA
            span.tertiary ]
          |  × 
          span(ev-tooltip="The proportion of people in CA that will leave for NY.")
            span.primary B₁[
            span.secondary NY
            span.primary ]
          |  + 
          span(ev-tooltip="The proportion of people in NY at t=0")
            span.tertiary P₀[
            span.secondary NY
            span.tertiary ]
          |  × 
          span(ev-tooltip="The proportion of people in NY that will stay in NY.")
            span.secondary B₂[NY]
        
        p(style="text-align: center; color: rgba(0, 0, 0, 0.4)") in our case...
        p(style="text-align: center")
          b {{opts.samples[1][1] | number:2 }}
          | &nbsp;&nbsp;=&nbsp;&nbsp; {{opts.samples[0][0] | number:2 }} 
          | &nbsp;&nbsp;×&nbsp;&nbsp; {{opts.basis1[1] | number:2 }}
          | &nbsp;&nbsp;+&nbsp;&nbsp; {{opts.samples[0][1] | number:2 }} 
          | &nbsp;&nbsp;×&nbsp;&nbsp; {{opts.basis2[0] | number:2 }}
        p For simple problems like this, we can get by with arithmetic but if we were dealing with all of the US states and every state could have people migrating to any other state, doing so would become difficult. This is where linear algebra can help condence our notation.
        p(style="text-align: center")
          span(ev-tooltip="A vector representing the proportion of people in each state at t=1.")
            span.tertiary P₁
          |  &nbsp;&nbsp;=&nbsp;&nbsp;
          span(ev-tooltip="A single scalar representing the proportion of people in CA at t=0 and the first component of the vector P₀.")
            span.tertiary P₀[
            span.primary CA
            span.tertiary ]
          | &nbsp;&nbsp;&nbsp;×&nbsp;&nbsp;&nbsp;
          span(ev-tooltip="A vector representing what the people in CA will do (either stay in CA, or move to NY).")
            span.primary B₁
          | &nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;
          span(ev-tooltip="A single scalar representing the proportion of people in NY at t=0 and the second component of the vector P₀.")
            span.tertiary P₀[
            span.secondary NY
            span.tertiary ]
          | &nbsp;&nbsp;×&nbsp;&nbsp; 
          span(ev-tooltip="A vector representing what the people in NY will do (either leave for CA, or stay in NY).")
            span.secondary B₂
        p(style="text-align: center; color: rgba(0, 0, 0, 0.4)") in our case...

        matrix-equation
          eq-vector(ev-tooltip="P₁" class="tertiary" values="opts.samples[1]" labels="['P₁[CA]', 'P₁[NY]']" active="true")
          | &nbsp;
          eq-element(label="'='")
          eq-element(ev-tooltip="P₀[CA]" class="tertiary" label="opts.sample[0] | number:2")
          | &nbsp;
          eq-element(label="'×'")
          | &nbsp;
          eq-vector(ev-tooltip="B₁" class="primary" values="opts.basis1" labels="['B₁[CA]', 'B₁[NY]']" active="true")
          | &nbsp;
          eq-element(label="'+'")
          | &nbsp;
          eq-element(ev-tooltip="P₀[NY]" class="tertiary" label="opts.sample[1] | number:2")
          | &nbsp;
          eq-element(label="'×'")
          | &nbsp;
          eq-vector(ev-tooltip="B₂" class="secondary" values="opts.basis2" labels="['B₂[CA]', 'B₂[NY]']" active="true")

        P
          :markdown
            Using this notation, we are describing P₁ as a [linear combination](https://en.wikipedia.org/wiki/Linear_combination) of P₀ applied to B₁ and B₂. This notation _really_ cuts down on how much typing we have to do, especially for larger, more interesting problems. We can also use this notation to help think about and visualize what's happening in a new way. The below interactive illustrates this by stepping through the process. Click "next" to begin.

        div(ng-controller="migrationLinearCombinationCtrl" style="position:relative")
          div(style="text-align:center")
            button.btn(ng-click="next()" ng-style="{ 'background-color': isLastKeyFrame ? 'rgba(0, 0, 0, 0.1)' : null }") {{isLastKeyFrame ? 'Reset' : 'Next'}}
          div.matrix-equation-highlight
            div.element-spotlight(ng-style="higlightedElementStyle")
          matrix-equation(style="padding: 10px;height: inherit;")
            eq-vector(ev-tooltip="P₁" class="tertiary" values="opts.samples[1]" labels="['P₁[CA]', 'P₁[NY]']" active="true")
            | &nbsp;
            eq-element(label="'='")
            eq-element(ev-tooltip="P₀[CA]" class="tertiary" label="opts.sample[0] | number:2")
            | &nbsp;
            eq-element(label="'×'")
            | &nbsp;
            eq-vector(ev-tooltip="B₁" class="primary" values="opts.basis1" labels="['B₁[CA]', 'B₁[NY]']" active="true")
            | &nbsp;
            eq-element(label="'+'")
            | &nbsp;
            eq-element(ev-tooltip="P₀[NY]" class="tertiary" label="opts.sample[1] | number:2")
            | &nbsp;
            eq-element(label="'×'")
            | &nbsp;
            eq-vector(ev-tooltip="B₂" class="secondary" values="opts.basis2" labels="['B₂[CA]', 'B₂[NY]']" active="true")
          migration-linear-combination

        div(style="padding-right:70px;padding-left:70px;")
          matrix-equation(style="width:25%;float:left")
            eq-element(class="primary" label="'B₁'")
            eq-element(label="'='")
            eq-vector(class="primary" values="opts.basis1" labels="['B₁[CA]', 'B₁[NY]']" active="true")
          matrix-equation(style="width:25%;float:left")
            eq-element(class="secondary" label="'B₂'")
            eq-element(label="'='")
            eq-vector(class="secondary" values="opts.basis2" labels="['B₂[CA]', 'B₂[NY]']" active="true")
          matrix-equation(style="width:25%;float:left")
            eq-element(class="tertiary" label="'P₀'")
            eq-element(label="'='")
            eq-vector(class="tertiary" values="opts.sample" labels="['P₀[CA]', 'P₀[NY]']" active="true")
          matrix-equation(style="width:25%;float:left")
            eq-element(class="tertiary" label="'P₁'")
            eq-element(label="'='")
            eq-vector(class="tertiary" values="opts.samples[1]" labels="['P₁[CA]', 'P₁[NY]']" active="true")
          div(style="clear:both")
          br
          br

        p This may seem all abstract, but try to hold on to what everything means. "B1" is how people act when in CA, "B2" is how people act in NY, "P0" is where people start off, "P1" is where people end up one month from now. In other words, we use what we know, B1 and B2 and P0, to calculate what we don't know, P1.
        p To calculate the populations two months from now (t=2), we can do all the same math, but replace P0 with our newly calculated value of P1.
        div(ng-controller="migrationLinearCombinationCtrl" style="position:relative")
          migration-repeated-linear-combination

        div(style="padding-right:70px;padding-left:70px;")
          matrix-equation(style="width:20%;float:left")
            eq-element(class="primary" label="'B₁'")
            eq-element(label="'='")
            eq-vector(class="primary" values="opts.basis1" labels="['B₁[CA]', 'B₁[NY]']" active="true")
          matrix-equation(style="width:20%;float:left")
            eq-element(class="secondary" label="'B₂'")
            eq-element(label="'='")
            eq-vector(class="secondary" values="opts.basis2" labels="['B₂[CA]', 'B₂[NY]']" active="true")
          matrix-equation(style="width:20%;float:left")
            eq-element(class="tertiary" label="'P₀'")
            eq-element(label="'='")
            eq-vector(class="tertiary" values="opts.sample" labels="['P₀[CA]', 'P₀[NY]']" active="true")
          matrix-equation(style="width:20%;float:left")
            eq-element(class="tertiary" label="'P₁'")
            eq-element(label="'='")
            eq-vector(class="tertiary" values="opts.samples[1]" labels="['P₁[CA]', 'P₁[NY]']" active="true")
          matrix-equation(style="width:20%;float:left")
            eq-element(class="tertiary" label="'P₂'")
            eq-element(label="'='")
            eq-vector(class="tertiary" values="opts.samples[2]" labels="['P₂[CA]', 'P₂[NY]']" active="true")
          div(style="clear:both")
          br
          br
        ev-placeholder(title="Eigen vector visualization")
      //- div(ng-controller="GeneralCtrl")
        h1 Linear combinations, more generally
        p Mention that the matrix above was a special case. Show how a linear combination works with a single point for non-stochastic matrices. The linear combation will be animated along the basis.
        ev-placeholder(title="Linear combination of a single point")
        p Show how a linear combination works with multiple points by allowing the user to draw a path/shape. Each point will animate to its new location.
        ev-placeholder(title="Linear combination of multiple drawn points")
        p Show how a image transformation is the same thing as a matrix transformation by repeatedly transforming the drawn shape. Allow the user to step forward/backward.
        ev-placeholder(title="Repeated matrix transformation")
        p Show a single point being multiplied to the matrix multiple times. Alow the user to step forward/backward.
        ev-placeholder(title="Tracking the path of only a single point")
        p See the entire trajectory of the repeated matrix multiplication of a single point.
        ev-placeholder(title="Trajectories")
        p  
        h1 Transforms
        matrix-as-image-transform
        h1 Eigen Vectors
        eigen-vectors
        //- eigen-space
        repeated-matrix-multiplication
    section
      h1 Migration
      div(ng-controller="StochasticMatrixMultiplicationCtrl" style="position:relative")
        migration(style="width:70%;float:left")
        stochastic-matrix-multiplication(style="width:30%;float:left")
        div(style="clear:both")
    section
        div(style="height:400px;width:100%;display:block;")
    div.layer.tooltips
    if !dev
      +footer
      +disqus
  script(src=basepath + "scripts/topojson.js" charset="utf-8")
  script(src=path + "script.js")
